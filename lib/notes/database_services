import 'package:cloud_firestore/cloud_firestore.dart';

class DatabaseService {
  final String? uid;

  DatabaseService({this.uid});

  // Firebase collections
  final CollectionReference userCollection =
  FirebaseFirestore.instance.collection("users");
  final CollectionReference groupCollection =
  FirebaseFirestore.instance.collection("groups");

  // Save user data when account is created
  Future<void> savingUserData(String fullName, String email) async {
    await userCollection.doc(uid).set({
      "fullName": fullName,
      "email": email,
      "groups": [],
      "profilePic": "",
      "uid": uid,
    });
  }

  // Get user data by email
  Future<QuerySnapshot> gettingUserData(String email) async {
    return await userCollection.where("email", isEqualTo: email).get();
  }

  // Listen to user's groups
  Stream<DocumentSnapshot> getUserGroups() {
    return userCollection.doc(uid).snapshots();
  }

  // Create a new group
  Future<void> createGroup(String userName, String id, String groupName) async {
    DocumentReference groupRef = await groupCollection.add({
      "groupName": groupName,
      "groupIcon": "",
      "admin": "${id}_$userName",
      "members": [],
      "groupId": "",
      "recentMessage": "",
      "recentMessageSender": "",
      "groupRequests": [],
      "createdAt": FieldValue.serverTimestamp(),
    });

    await groupRef.update({
      "members": FieldValue.arrayUnion(["${uid}_$userName"]),
      "groupId": groupRef.id,
    });

    await userCollection.doc(uid).update({
      "groups": FieldValue.arrayUnion(["${groupRef.id}_$groupName"]),
    });
  }

  // Stream of chat messages for a group
  Stream<QuerySnapshot> getChats(String groupId) {
    return groupCollection
        .doc(groupId)
        .collection("messages")
        .orderBy("time")
        .snapshots();
  }

  // Get group admin
  Future<String> getGroupAdmin(String groupId) async {
    DocumentSnapshot snapshot = await groupCollection.doc(groupId).get();
    return snapshot['admin'];
  }

  // Get group members stream
  Stream<DocumentSnapshot> getGroupMembers(String groupId) {
    return groupCollection.doc(groupId).snapshots();
  }

  // Search for group by name
  Future<QuerySnapshot> searchByName(String groupName) {
    return groupCollection
        .where("groupName", isEqualTo: groupName)
        .get();
  }

  // Check if user is joined
  Future<bool> isUserJoined(String groupName, String groupId, String userName) async {
    DocumentSnapshot snapshot = await userCollection.doc(uid).get();
    List<dynamic> groups = snapshot['groups'];
    return groups.contains("${groupId}_$groupName");
  }

  // Join group (after approval)
  Future<void> joinGroup(String groupId, String groupName) async {
    DocumentSnapshot userDoc = await userCollection.doc(uid).get();
    String userName = userDoc['fullName'] ?? '';
    String fullUserString = "${uid}_$userName";

    await groupCollection.doc(groupId).update({
      "members": FieldValue.arrayUnion([fullUserString]),
    });

    await userCollection.doc(uid).update({
      "groups": FieldValue.arrayUnion(["${groupId}_$groupName"]),
    });
  }

  // Leave group with all safety checks
  Future<void> leaveGroup(String groupId, String groupName) async {
    final userDoc = await userCollection.doc(uid).get();
    final userName = userDoc['fullName'] ?? '';
    final fullUserString = "${uid}_$userName";

    final groupDoc = await groupCollection.doc(groupId).get();
    final admin = groupDoc['admin'] as String;
    final isAdmin = admin == fullUserString;
    final members = List.from(groupDoc['members'] ?? []);
    final isLastMember = members.length == 1 && members.contains(fullUserString);

    if (isLastMember) {
      await _deleteEntireGroup(groupId, groupName);
    } else if (isAdmin) {
      throw Exception("Cannot leave as admin. Transfer admin rights first.");
    } else {
      await groupCollection.doc(groupId).update({
        "members": FieldValue.arrayRemove([fullUserString]),
      });
    }

    await userCollection.doc(uid).update({
      "groups": FieldValue.arrayRemove(["${groupId}_$groupName"]),
    });
  }

  // Delete entire group and clean up
  Future<void> _deleteEntireGroup(String groupId, String groupName) async {
    WriteBatch batch = FirebaseFirestore.instance.batch();

    // Delete group document
    batch.delete(groupCollection.doc(groupId));

    // Delete all messages
    final messages = await groupCollection.doc(groupId).collection("messages").get();
    for (var doc in messages.docs) {
      batch.delete(doc.reference);
    }

    await batch.commit();
  }

  // Transfer admin rights
  Future<void> transferAdminRights({
    required String groupId,
    required String newAdminId,
    required String newAdminName,
  }) async {
    final newAdminString = "${newAdminId}_$newAdminName";

    await groupCollection.doc(groupId).update({
      "admin": newAdminString,
      "members": FieldValue.arrayUnion([newAdminString]),
    });
  }

  // Send message
  Future<void> sendMessage(String groupId, Map<String, dynamic> chatMessageData) async {
    await groupCollection.doc(groupId).collection("messages").add(chatMessageData);
    await groupCollection.doc(groupId).update({
      "recentMessage": chatMessageData['message'],
      "recentMessageSender": chatMessageData['sender'],
      "recentMessageTime": chatMessageData['time'].toString(),
    });
  }

  // Handle join requests
  Future<void> sendJoinRequest(String groupId, String userName, String userId) async {
    final requestId = "${userId}_$userName";
    await groupCollection.doc(groupId).update({
      "groupRequests": FieldValue.arrayUnion([requestId])
    });
  }

  // Approve join request
  Future<void> approveJoinRequest({
    required String groupId,
    required String groupName,
    required String userId,
    required String userName,
    required String assignedName,
  }) async {
    final fullId = "${userId}_$userName";

    await groupCollection.doc(groupId).update({
      "members": FieldValue.arrayUnion([fullId]),
      "groupRequests": FieldValue.arrayRemove([fullId]),
      "groupAnonNames": {userId: assignedName},
    });

    await userCollection.doc(userId).update({
      "groups": FieldValue.arrayUnion(["${groupId}_$groupName"]),
    });
  }

  // Remove member
  Future<void> removeMemberFromGroup({
    required String groupId,
    required String groupName,
    required String memberId,
    required String memberName,
    required String fullMemberString,
  }) async {
    await groupCollection.doc(groupId).update({
      "members": FieldValue.arrayRemove([fullMemberString])
    });

    await userCollection.doc(memberId).update({
      "groups": FieldValue.arrayRemove(["${groupId}_$groupName"])
    });
  }
}


  static const String _backendUrl = 'http://192.168.1.69:8000/api/uploadmedia';
  static const String _serverBaseUrl = 'http://192.168.1.69:8000';